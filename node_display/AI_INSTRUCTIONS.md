# ü§ñ –ü–û–õ–ù–ê–Ø –ò–ù–°–¢–†–£–ö–¶–ò–Ø –î–õ–Ø –ò–ò: NODE Display

**–õ–æ–∫–∞–ª—å–Ω—ã–π –¥–∏—Å–ø–ª–µ–π –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤—Å–µ–π mesh-—Å–∏—Å—Ç–µ–º—ã (–±–µ–∑ —Å–º–∞—Ä—Ç—Ñ–æ–Ω–∞/–∫–æ–º–ø—å—é—Ç–µ—Ä–∞)**

---

## üéØ –ù–ê–ó–ù–ê–ß–ï–ù–ò–ï –£–ó–õ–ê

**NODE Display (ESP32-S3 #2 —Å PSRAM 8MB)** - –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–æ–π.

### üì∫ –ö–ª—é—á–µ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:

1. **TFT –¥–∏—Å–ø–ª–µ–π 320x240** - ILI9341 —á–µ—Ä–µ–∑ SPI (–ø–æ–ª–Ω–æ—Ü–≤–µ—Ç–Ω—ã–π)
2. **LVGL GUI** - —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å –∞–Ω–∏–º–∞—Ü–∏—è–º–∏
3. **–†–æ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π —ç–Ω–∫–æ–¥–µ—Ä** - –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∏ –≤—ã–±–æ—Ä (—Å –∫–Ω–æ–ø–∫–æ–π)
4. **–ó–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö** - REQUEST –∫ ROOT ‚Üí RESPONSE —Å–æ –≤—Å–µ–º–∏ —É–∑–ª–∞–º–∏
5. **–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö** - –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
6. **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É–∑–ª–∞–º–∏** - –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥ —á–µ—Ä–µ–∑ ROOT
7. **Heartbeat** - –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏

### ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–´–ï –ü–†–ê–í–ò–õ–ê:

1. ‚úÖ **–¢–†–ï–ë–£–ï–¢ PSRAM 8MB!** - LVGL + TFT –±—É—Ñ–µ—Ä—ã —Ç—Ä–µ–±—É—é—Ç –º–Ω–æ–≥–æ –ø–∞–º—è—Ç–∏
2. ‚ùå **–ù–ï–¢ –î–ê–¢–ß–ò–ö–û–í!** - Display –ù–ï —á–∏—Ç–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –¥–∞—Ç—á–∏–∫–∏
3. ‚ùå **–ù–ï–¢ –ò–°–ü–û–õ–ù–ò–¢–ï–õ–ï–ô!** - Display –ù–ï —É–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–ª–µ/–Ω–∞—Å–æ—Å–∞–º–∏ –Ω–∞–ø—Ä—è–º—É—é
4. ‚úÖ **–ó–ê–ü–†–û–°–´ –ß–ï–†–ï–ó ROOT** - –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ REQUEST/RESPONSE –ø—Ä–æ—Ç–æ–∫–æ–ª
5. ‚úÖ **–ö–û–ú–ê–ù–î–´ –ß–ï–†–ï–ó ROOT** - –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥ –¥—Ä—É–≥–∏–º —É–∑–ª–∞–º —á–µ—Ä–µ–∑ ROOT
6. ‚úÖ **–û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–û –¢–ê–ô–ú–ï–†–£** - –∑–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥

---

## üì¶ –û–ë–û–†–£–î–û–í–ê–ù–ò–ï

### TFT –î–∏—Å–ø–ª–µ–π:
| –ü–∞—Ä–∞–º–µ—Ç—Ä | –ó–Ω–∞—á–µ–Ω–∏–µ |
|----------|----------|
| **–ú–æ–¥–µ–ª—å** | ILI9341 |
| **–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ** | 320x240 –ø–∏–∫—Å–µ–ª–µ–π |
| **–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å** | SPI (40 MHz) |
| **–¶–≤–µ—Ç–∞** | 16-bit RGB565 (65K colors) |
| **–ü–æ–¥—Å–≤–µ—Ç–∫–∞** | PWM 0-100% |
| **Touch** | –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ (XPT2046) |

### –†–æ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π —ç–Ω–∫–æ–¥–µ—Ä:
| –ü–∞—Ä–∞–º–µ—Ç—Ä | –ó–Ω–∞—á–µ–Ω–∏–µ |
|----------|----------|
| **–¢–∏–ø** | KY-040 –∏–ª–∏ –∞–Ω–∞–ª–æ–≥ |
| **–í—ã—Ö–æ–¥—ã** | CLK (A), DT (B), SW (button) |
| **–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ** | 20 –∏–º–ø—É–ª—å—Å–æ–≤ –Ω–∞ –æ–±–æ—Ä–æ—Ç |
| **Debouncing** | –ü—Ä–æ–≥—Ä–∞–º–º–Ω—ã–π (10ms) |

---

## üîå –†–ê–°–ü–ò–ù–û–í–ö–ê ESP32-S3 #2

| GPIO | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ | –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ |
|------|------------|-----------|------------|
| **SPI –¥–ª—è TFT (VSPI):** | | | |
| 23 | MOSI | ILI9341 | Master Out Slave In |
| 18 | SCK | ILI9341 | Clock (40 MHz) |
| 5 | CS | ILI9341 | Chip Select |
| 2 | DC | ILI9341 | Data/Command |
| 4 | RST | ILI9341 | Reset |
| 15 | Backlight | PWM | 0-100% —è—Ä–∫–æ—Å—Ç—å |
| **–†–æ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π —ç–Ω–∫–æ–¥–µ—Ä:** | | | |
| 32 | Encoder CLK | KY-040 pin A | Pullup –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π |
| 33 | Encoder DT | KY-040 pin B | Pullup –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π |
| 25 | Encoder SW | Button | Pullup –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π |
| **–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π Touch:** | | | |
| 19 | Touch MISO | XPT2046 | –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è |
| 26 | Touch IRQ | XPT2046 | Interrupt |

---

## üèóÔ∏è –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ü–û –ö–û–ú–ü–û–ù–ï–ù–¢–ê–ú

```
node_display/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ lcd_driver/           # ILI9341 SPI driver
‚îÇ   ‚îú‚îÄ‚îÄ lvgl_port/            # LVGL –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ESP32
‚îÇ   ‚îú‚îÄ‚îÄ encoder_driver/       # –†–æ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π —ç–Ω–∫–æ–¥–µ—Ä + button
‚îÇ   ‚îú‚îÄ‚îÄ ui_screens/           # LVGL —ç–∫—Ä–∞–Ω—ã
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui_dashboard.c   # –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω (–≤—Å–µ —É–∑–ª—ã)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui_node_detail.c # –î–µ—Ç–∞–ª–∏ —É–∑–ª–∞
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui_node_list.c   # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —É–∑–ª–æ–≤
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui_settings.c    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Display
‚îÇ   ‚îú‚îÄ‚îÄ display_controller/   # –õ–æ–≥–∏–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
‚îÇ   ‚îî‚îÄ‚îÄ command_sender/       # –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥ —É–∑–ª–∞–º
‚îÇ
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îî‚îÄ‚îÄ app_main.c            # Mesh callback + LVGL init
‚îÇ
‚îî‚îÄ‚îÄ AI_INSTRUCTIONS_COMPLETE.md  # ‚Üê –≠–¢–ê –ò–ù–°–¢–†–£–ö–¶–ò–Ø
```

---

## üì® –¢–ò–ü–´ –°–û–û–ë–©–ï–ù–ò–ô

### 1. üì§ REQUEST (Display ‚Üí ROOT)

**–ó–∞–ø—Ä–æ—Å –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–æ–≤:**

```json
{
  "type": "request",
  "from": "display_001",
  "request": "all_nodes_data"
}
```

**–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏:**
```c
void request_all_nodes_data(void) {
    char json_buf[256];
    
    if (mesh_protocol_create_request(s_config->base.node_id, "all_nodes_data",
                                      json_buf, sizeof(json_buf))) {
        esp_err_t err = mesh_manager_send_to_root((uint8_t *)json_buf, strlen(json_buf));
        
        if (err == ESP_OK) {
            ESP_LOGD(TAG, "Data request sent to ROOT");
        } else {
            ESP_LOGW(TAG, "Failed to send request: %s", esp_err_to_name(err));
        }
    }
}
```

**–ß–∞—Å—Ç–æ—Ç–∞:** –ö–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –∑–∞–¥–∞—á–µ)

---

### 2. üì• RESPONSE (ROOT ‚Üí Display)

**–û—Ç–≤–µ—Ç –æ—Ç ROOT —Å–æ –≤—Å–µ–º–∏ —É–∑–ª–∞–º–∏:**

```json
{
  "type": "response",
  "to": "display_001",
  "data": {
    "nodes": [
      {
        "node_id": "climate_001",
        "node_type": "climate",
        "online": true,
        "data": {
          "temperature": 24.5,
          "humidity": 65,
          "co2": 820,
          "lux": 450
        }
      },
      {
        "node_id": "ph_ec_001",
        "node_type": "ph_ec",
        "online": true,
        "data": {
          "ph": 6.5,
          "ec": 1.8,
          "temperature": 22.5
        }
      },
      {
        "node_id": "relay_001",
        "node_type": "relay",
        "online": true,
        "data": {
          "window_1": "closed",
          "window_2": "open",
          "fan": "on",
          "led_brightness": 75
        }
      },
      {
        "node_id": "water_001",
        "node_type": "water",
        "online": true,
        "data": {
          "water_level_cm": 45,
          "water_level_percent": 75,
          "pump_running": false
        }
      }
    ]
  }
}
```

**–û–±—Ä–∞–±–æ—Ç–∫–∞:**
```c
static void on_mesh_data_received(const uint8_t *src, const uint8_t *data, size_t len) {
    char *data_copy = malloc(len + 1);
    if (!data_copy) return;
    memcpy(data_copy, data, len);
    data_copy[len] = '\0';
    
    mesh_message_t msg;
    if (!mesh_protocol_parse(data_copy, &msg)) {
        free(data_copy);
        return;
    }
    
    if (strcmp(msg.node_id, s_config->base.node_id) != 0) {
        free(data_copy);
        mesh_protocol_free_message(&msg);
        return;
    }

    if (msg.type == MESH_MSG_RESPONSE) {
        display_controller_handle_response(&msg);
    }

    free(data_copy);
    mesh_protocol_free_message(&msg);
}

void display_controller_handle_response(mesh_message_t *msg) {
    cJSON *nodes_array = cJSON_GetObjectItem(msg->data, "nodes");
    if (!nodes_array || !cJSON_IsArray(nodes_array)) {
        ESP_LOGE(TAG, "Invalid response format");
        return;
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ —É–∑–ª–æ–≤
    display_cache_update(nodes_array);
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
    ui_update_all_screens();
    
    ESP_LOGI(TAG, "Received data for %d nodes", cJSON_GetArraySize(nodes_array));
}
```

---

### 3. üì§ COMMAND (Display ‚Üí ROOT ‚Üí Target NODE)

**Display –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∫–æ–º–∞–Ω–¥—ã –¥—Ä—É–≥–∏–º —É–∑–ª–∞–º —á–µ—Ä–µ–∑ ROOT:**

```json
{
  "type": "command",
  "node_id": "relay_001",
  "command": "set_fan",
  "params": {
    "state": "on",
    "speed": 75
  },
  "from": "display_001"
}
```

**–ö–æ–¥:**
```c
void display_send_command_to_node(const char *target_node_id, 
                                   const char *command, 
                                   cJSON *params) {
    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "type", "command");
    cJSON_AddStringToObject(root, "node_id", target_node_id);
    cJSON_AddStringToObject(root, "command", command);
    cJSON_AddItemToObject(root, "params", cJSON_Duplicate(params, true));
    cJSON_AddStringToObject(root, "from", s_config->base.node_id);
    
    char json_buf[512];
    char *json_str = cJSON_PrintUnformatted(root);
    if (json_str) {
        strncpy(json_buf, json_str, sizeof(json_buf) - 1);
        free(json_str);
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ ROOT (–æ–Ω –ø–µ—Ä–µ—à–ª—ë—Ç target —É–∑–ª—É)
        mesh_manager_send_to_root((uint8_t *)json_buf, strlen(json_buf));
        
        ESP_LOGI(TAG, "Command sent to %s: %s", target_node_id, command);
    }
    
    cJSON_Delete(root);
}
```

---

### 4. üíì HEARTBEAT (–∫–∞–∂–¥—ã–µ 10 —Å–µ–∫)

```json
{
  "type": "heartbeat",
  "node_id": "display_001",
  "uptime": 3600,
  "heap_free": 3500000,
  "rssi_to_parent": -45
}
```

---

## üì∫ LVGL UI SCREENS

### 1. Dashboard (–≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üåø HYDRO MESH SYSTEM v2.0       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚ï≠‚îÄ Climate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ON ‚îÄ‚ïÆ ‚îÇ
‚îÇ  ‚îÇ  üå° 24.5¬∞C   üíß 65%          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  CO2: 820ppm   Lux: 450      ‚îÇ ‚îÇ
‚îÇ  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚ï≠‚îÄ pH/EC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ON ‚îÄ‚ïÆ‚îÇ
‚îÇ  ‚îÇ  pH: 6.5   EC: 1.8 mS/cm    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Temp: 22.5¬∞C                ‚îÇ ‚îÇ
‚îÇ  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚ï≠‚îÄ Relay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ON ‚îÄ‚ïÆ‚îÇ
‚îÇ  ‚îÇ  Fan: ON 100%  Light: 75%   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Window: OPEN                ‚îÇ ‚îÇ
‚îÇ  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚ï≠‚îÄ Water ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ON ‚îÄ‚ïÆ‚îÇ
‚îÇ  ‚îÇ  Level: 45cm (75%)           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Pump: OFF                   ‚îÇ ‚îÇ
‚îÇ  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  Last update: 2s ago             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**LVGL –∫–æ–¥:**
```c
void ui_create_dashboard_screen(void) {
    lv_obj_t *screen = lv_obj_create(NULL);
    
    // –ó–∞–≥–æ–ª–æ–≤–æ–∫
    lv_obj_t *title = lv_label_create(screen);
    lv_label_set_text(title, "üåø HYDRO MESH SYSTEM v2.0");
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 10);
    
    // –ö–∞—Ä—Ç–æ—á–∫–∏ —É–∑–ª–æ–≤
    lv_obj_t *climate_card = create_node_card(screen, "Climate", 0, 40);
    lv_obj_t *ph_ec_card = create_node_card(screen, "pH/EC", 0, 110);
    lv_obj_t *relay_card = create_node_card(screen, "Relay", 0, 180);
    lv_obj_t *water_card = create_node_card(screen, "Water", 0, 250);
    
    // –°—Ç–∞—Ç—É—Å –±–∞—Ä
    lv_obj_t *status = lv_label_create(screen);
    lv_label_set_text(status, "Last update: 0s ago");
    lv_obj_align(status, LV_ALIGN_BOTTOM_MID, 0, -10);
    
    lv_scr_load(screen);
}

lv_obj_t *create_node_card(lv_obj_t *parent, const char *name, int x, int y) {
    // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–∞—Ä—Ç–æ—á–∫–∏
    lv_obj_t *card = lv_obj_create(parent);
    lv_obj_set_size(card, 300, 60);
    lv_obj_set_pos(card, x + 10, y);
    lv_obj_set_style_radius(card, 10, 0);
    lv_obj_set_style_bg_color(card, lv_color_hex(0x2C3E50), 0);
    
    // –ù–∞–∑–≤–∞–Ω–∏–µ —É–∑–ª–∞
    lv_obj_t *label = lv_label_create(card);
    lv_label_set_text(label, name);
    lv_obj_set_style_text_font(label, &lv_font_montserrat_16, 0);
    lv_obj_align(label, LV_ALIGN_TOP_LEFT, 10, 5);
    
    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä ONLINE
    lv_obj_t *status_led = lv_led_create(card);
    lv_obj_set_size(status_led, 12, 12);
    lv_obj_align(status_led, LV_ALIGN_TOP_RIGHT, -10, 8);
    lv_led_set_color(status_led, lv_color_hex(0x00FF00));  // –ó–µ–ª–µ–Ω—ã–π
    lv_led_on(status_led);
    
    // –î–∞–Ω–Ω—ã–µ —É–∑–ª–∞
    lv_obj_t *data_label = lv_label_create(card);
    lv_label_set_text(data_label, "Loading...");
    lv_obj_align(data_label, LV_ALIGN_CENTER, 0, 10);
    
    return card;
}
```

---

### 2. Node Detail (–¥–µ—Ç–∞–ª—å–Ω—ã–π —ç–∫—Ä–∞–Ω —É–∑–ª–∞):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚Üê Back          Climate Node    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üå° Temperature:  24.5¬∞C         ‚îÇ
‚îÇ     ‚îú‚îÄ Target: 24.0¬∞C            ‚îÇ
‚îÇ     ‚îî‚îÄ Status: ‚úÖ Normal         ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  üíß Humidity:  65%               ‚îÇ
‚îÇ     ‚îú‚îÄ Target: 65%               ‚îÇ
‚îÇ     ‚îî‚îÄ Status: ‚úÖ Normal         ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  CO2:  820 ppm                   ‚îÇ
‚îÇ     ‚îú‚îÄ Target: 800 ppm           ‚îÇ
‚îÇ     ‚îî‚îÄ Status: ‚ö†Ô∏è Slightly high  ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  Lux:  450                       ‚îÇ
‚îÇ     ‚îî‚îÄ Target: 500               ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  üì° RSSI: -42 dBm (Excellent)    ‚îÇ
‚îÇ  ‚è± Uptime: 2h 15m                ‚îÇ
‚îÇ  üíæ Free heap: 158 KB            ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  [Settings] [Commands]           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 3. Command Panel (—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É–∑–ª–æ–º):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Control: climate_001            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üìù Commands:                    ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Set Read Interval           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Üí 30 seconds                ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Restart Sensor              ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Reset Statistics            ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚ö†Ô∏è Use encoder to select        ‚îÇ
‚îÇ  Press button to confirm         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª –ì–õ–ê–í–ù–ê–Ø –õ–û–ì–ò–ö–ê

### app_main.c:

```c
#include "lvgl.h"
#include "lcd_driver.h"
#include "encoder_driver.h"
#include "mesh_manager.h"
#include "mesh_protocol.h"
#include "display_controller.h"
#include "ui_screens.h"

static display_node_config_t g_config;

// Mesh callback
static void on_mesh_data_received(const uint8_t *src, const uint8_t *data, size_t len) {
    char *data_copy = malloc(len + 1);
    if (!data_copy) return;
    memcpy(data_copy, data, len);
    data_copy[len] = '\0';
    
    mesh_message_t msg;
    if (!mesh_protocol_parse(data_copy, &msg)) {
        free(data_copy);
        return;
    }
    
    if (strcmp(msg.node_id, g_config.base.node_id) != 0) {
        free(data_copy);
        mesh_protocol_free_message(&msg);
        return;
    }

    switch (msg.type) {
        case MESH_MSG_RESPONSE:
            display_controller_handle_response(&msg);
            break;

        case MESH_MSG_CONFIG:
            display_controller_handle_config(&msg);
            break;

        default:
            ESP_LOGW(TAG, "Unknown message type: %d", msg.type);
            break;
    }

    free(data_copy);
    mesh_protocol_free_message(&msg);
}

void app_main(void) {
    // === –®–∞–≥ 1: NVS ===
    nvs_flash_init();
    
    // === –®–∞–≥ 2: –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ===
    node_config_load(&g_config, sizeof(g_config), "display_ns");
    
    // === –®–∞–≥ 3: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LCD (SPI) ===
    lcd_driver_init();
    
    // === –®–∞–≥ 4: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LVGL ===
    lv_init();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–æ–≤ (–¢–†–ï–ë–£–ï–¢ PSRAM!)
    static lv_color_t buf1[LCD_WIDTH * 40];  // 320*40*2 = 25.6 KB
    static lv_color_t buf2[LCD_WIDTH * 40];
    
    lv_display_t *disp = lv_display_create(LCD_WIDTH, LCD_HEIGHT);
    lv_display_set_flush_cb(disp, lcd_flush_cb);
    lv_display_set_buffers(disp, buf1, buf2, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);
    
    // === –®–∞–≥ 5: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–Ω–∫–æ–¥–µ—Ä–∞ ===
    encoder_driver_init();
    
    // Input device –¥–ª—è LVGL
    lv_indev_t *encoder_indev = lv_indev_create();
    lv_indev_set_type(encoder_indev, LV_INDEV_TYPE_ENCODER);
    lv_indev_set_read_cb(encoder_indev, encoder_read_cb);
    
    // === –®–∞–≥ 6: –°–æ–∑–¥–∞–Ω–∏–µ UI ===
    ui_create_dashboard_screen();
    
    // === –®–∞–≥ 7: Mesh (NODE —Ä–µ–∂–∏–º) ===
    mesh_manager_config_t mesh_config = {
        .mode = MESH_MODE_NODE,
        .mesh_id = MESH_NETWORK_ID,
        .mesh_password = MESH_NETWORK_PASSWORD,
        .channel = MESH_NETWORK_CHANNEL,
        .max_connection = 6,
        .router_ssid = MESH_ROUTER_SSID,
        .router_password = MESH_ROUTER_PASSWORD,
        .router_bssid = NULL
    };
    mesh_manager_init(&mesh_config);
    mesh_manager_register_recv_cb(on_mesh_data_received);
    mesh_manager_start();
    
    // === –®–∞–≥ 8: –ó–∞–ø—É—Å–∫ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ ===
    display_controller_init(&g_config);
    display_controller_start();
    
    // === –®–∞–≥ 9: LVGL timer task ===
    xTaskCreate(lvgl_timer_task, "lvgl_timer", 4096, NULL, 5, NULL);
}
```

---

## üîÑ –û–ë–ù–û–í–õ–ï–ù–ò–ï –î–ê–ù–ù–´–•

### –ó–∞–¥–∞—á–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:

```c
static void display_update_task(void *arg) {
    ESP_LOGI(TAG, "Update task running (request data every 5 sec)");
    
    // –ù–∞—á–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (–∂–¥—ë–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ mesh)
    vTaskDelay(pdMS_TO_TICKS(10000));
    
    while (1) {
        if (mesh_manager_is_connected()) {
            // –ó–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö —É ROOT
            request_all_nodes_data();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ü–∏–∏ —Å–≤—è–∑–∏
            ui_update_connection_status(true);
        } else {
            // –ü–æ–∫–∞–∑ offline —Å—Ç–∞—Ç—É—Å–∞
            ui_update_connection_status(false);
        }
        
        vTaskDelay(pdMS_TO_TICKS(5000));  // –ö–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
    }
}
```

---

## üéÆ –ù–ê–í–ò–ì–ê–¶–ò–Ø –≠–ù–ö–û–î–ï–†–û–ú

### –û–±—Ä–∞–±–æ—Ç–∫–∞ —ç–Ω–∫–æ–¥–µ—Ä–∞:

```c
typedef enum {
    SCREEN_DASHBOARD = 0,
    SCREEN_CLIMATE_DETAIL,
    SCREEN_PH_EC_DETAIL,
    SCREEN_RELAY_DETAIL,
    SCREEN_WATER_DETAIL,
    SCREEN_SETTINGS
} screen_type_t;

static screen_type_t current_screen = SCREEN_DASHBOARD;
static int selected_item = 0;

void encoder_read_cb(lv_indev_t *indev, lv_indev_data_t *data) {
    static int last_enc_value = 0;
    int enc_value = encoder_get_value();
    
    // –í—Ä–∞—â–µ–Ω–∏–µ
    int diff = enc_value - last_enc_value;
    last_enc_value = enc_value;
    
    data->enc_diff = diff;
    
    // –ö–Ω–æ–ø–∫–∞
    data->state = encoder_is_pressed() ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
}

void encoder_event_handler(int encoder_value, bool button_pressed) {
    if (current_screen == SCREEN_DASHBOARD) {
        // –í—ã–±–æ—Ä —É–∑–ª–∞ (0-4)
        selected_item = (encoder_value / 4) % 5;  // 5 —É–∑–ª–æ–≤ (ROOT + 4 NODE)
        ui_highlight_item(selected_item);
        
        // –ù–∞–∂–∞—Ç–∏–µ - –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –¥–µ—Ç–∞–ª—å–Ω—ã–π —ç–∫—Ä–∞–Ω
        if (button_pressed) {
            switch (selected_item) {
                case 0:
                    ui_load_screen(SCREEN_CLIMATE_DETAIL);
                    break;
                case 1:
                    ui_load_screen(SCREEN_PH_EC_DETAIL);
                    break;
                // ...
            }
        }
    }
}
```

---

## ‚ùå –ß–¢–û –ù–ï –î–ï–õ–ê–¢–¨

### 1. ‚ùå –ù–ï –∑–∞–ø—Ä–∞—à–∏–≤–∞–π –¥–∞–Ω–Ω—ã–µ —É NODE –Ω–∞–ø—Ä—è–º—É—é

```c
// –ü–õ–û–•–û ‚ùå
// –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å request –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ climate_001
mesh_manager_send(climate_mac, request, len);  // ‚ùå NODE –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç REQUEST!

// –•–û–†–û–®–û ‚úÖ
// –ó–∞–ø—Ä–æ—Å —É ROOT, –æ–Ω —Å–æ–±–µ—Ä—ë—Ç –¥–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö —É–∑–ª–æ–≤
mesh_manager_send_to_root(request, len);  // ‚úÖ ROOT –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç REQUEST
```

### 2. ‚ùå –ù–ï –±–ª–æ–∫–∏—Ä—É–π UI –æ–∂–∏–¥–∞–Ω–∏–µ–º –æ—Ç–≤–µ—Ç–∞

```c
// –ü–õ–û–•–û ‚ùå
void button_click() {
    send_request();
    while (!response_received) {  // ‚ùå –ó–∞–≤–∏—Å–∞–Ω–∏–µ UI!
        vTaskDelay(100);
    }
    update_ui();
}

// –•–û–†–û–®–û ‚úÖ
void button_click() {
    send_request();  // ‚úÖ –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
    // –û—Ç–≤–µ—Ç –ø—Ä–∏–¥–µ—Ç –≤ callback on_mesh_data_received
    // UI –æ–±–Ω–æ–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
}
```

### 3. ‚ùå –ù–ï —Å–æ–∑–¥–∞–≤–∞–π LVGL –æ–±—ä–µ–∫—Ç—ã –±–µ–∑ PSRAM

```c
// –ü–õ–û–•–û ‚ùå
// –ù–∞ ESP32 –±–µ–∑ PSRAM:
static lv_color_t buf[LCD_WIDTH * LCD_HEIGHT];  // ‚ùå 320*240*2 = 153 KB - –Ω–µ –≤–ª–µ–∑–µ—Ç!

// –•–û–†–û–®–û ‚úÖ
// –° PSRAM (ESP32-S3):
static lv_color_t buf1[LCD_WIDTH * 40];  // 25.6 KB –≤ PSRAM
static lv_color_t buf2[LCD_WIDTH * 40];  // –î–≤–æ–π–Ω–∞—è –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è
```

---

## üîß –ö–û–ú–ü–û–ù–ï–ù–¢–´ (—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)

### components/lcd_driver/:
```c
esp_err_t lcd_driver_init(void);
void lcd_driver_set_backlight(uint8_t brightness);
void lcd_flush_cb(lv_display_t *disp, const lv_area_t *area, uint8_t *color_p);
```

### components/encoder_driver/:
```c
esp_err_t encoder_driver_init(void);
int encoder_get_value(void);
bool encoder_is_pressed(void);
void encoder_reset(void);
```

### components/display_controller/:
```c
esp_err_t display_controller_init(display_node_config_t *config);
esp_err_t display_controller_start(void);
void display_controller_request_data(void);
void display_controller_handle_response(mesh_message_t *msg);
void display_controller_send_command(const char *node_id, const char *command, cJSON *params);
```

### components/ui_screens/:
```c
void ui_create_dashboard_screen(void);
void ui_create_node_detail_screen(const char *node_id);
void ui_update_node_card(const char *node_id, cJSON *data);
void ui_show_error(const char *message);
```

---

## üß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï

### –ü—Ä–æ–≤–µ—Ä–∫–∞ REQUEST/RESPONSE:

1. –ó–∞–ø—É—Å—Ç–∏ Display NODE
2. –ó–∞–ø—É—Å—Ç–∏ ROOT
3. **–ü—Ä–æ–≤–µ—Ä—å –ª–æ–≥ Display:**

```
I (10000) DISPLAY: Mesh connected
I (10010) display_ctrl: Requesting data from ROOT...
I (10200) DISPLAY: Response from ROOT received
I (10210) display_ctrl: 4 nodes in cache
I (10220) ui: Dashboard updated
```

4. **–ü—Ä–æ–≤–µ—Ä—å –ª–æ–≥ ROOT:**

```
I (10100) data_router: Request from display_001 (Display)
I (10110) data_router: Request type: all_nodes_data
I (10120) data_router: Sent response to Display (4 nodes, 1024 bytes)
```

---

## üìä –ö–≠–®–ò–†–û–í–ê–ù–ò–ï –î–ê–ù–ù–´–•

### –õ–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à —É–∑–ª–æ–≤:

```c
#define MAX_CACHED_NODES 10

typedef struct {
    char node_id[32];
    char node_type[16];
    bool online;
    uint64_t last_update;
    cJSON *data;  // –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ —É–∑–ª–∞
} cached_node_t;

static cached_node_t g_nodes_cache[MAX_CACHED_NODES];
static int g_cache_count = 0;
static SemaphoreHandle_t g_cache_mutex;

void display_cache_update(cJSON *nodes_array) {
    xSemaphoreTake(g_cache_mutex, portMAX_DELAY);
    
    // –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞
    for (int i = 0; i < g_cache_count; i++) {
        if (g_nodes_cache[i].data) {
            cJSON_Delete(g_nodes_cache[i].data);
        }
    }
    
    g_cache_count = 0;
    
    // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫—ç—à–∞
    int array_size = cJSON_GetArraySize(nodes_array);
    for (int i = 0; i < array_size && i < MAX_CACHED_NODES; i++) {
        cJSON *node = cJSON_GetArrayItem(nodes_array, i);
        
        cJSON *node_id = cJSON_GetObjectItem(node, "node_id");
        cJSON *node_type = cJSON_GetObjectItem(node, "node_type");
        cJSON *online = cJSON_GetObjectItem(node, "online");
        
        if (node_id && node_type) {
            strncpy(g_nodes_cache[i].node_id, node_id->valuestring, 31);
            strncpy(g_nodes_cache[i].node_type, node_type->valuestring, 15);
            g_nodes_cache[i].online = online ? cJSON_IsTrue(online) : false;
            g_nodes_cache[i].last_update = esp_timer_get_time() / 1000000;
            g_nodes_cache[i].data = cJSON_Duplicate(node, true);
            
            g_cache_count++;
        }
    }
    
    xSemaphoreGive(g_cache_mutex);
    
    ESP_LOGI(TAG, "Cache updated: %d nodes", g_cache_count);
}

cached_node_t *display_cache_get(const char *node_id) {
    xSemaphoreTake(g_cache_mutex, portMAX_DELAY);
    
    for (int i = 0; i < g_cache_count; i++) {
        if (strcmp(g_nodes_cache[i].node_id, node_id) == 0) {
            xSemaphoreGive(g_cache_mutex);
            return &g_nodes_cache[i];
        }
    }
    
    xSemaphoreGive(g_cache_mutex);
    return NULL;
}
```

---

## üåê MESH INTEGRATION

### –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (NODE —Ä–µ–∂–∏–º):

```c
mesh_manager_config_t mesh_config = {
    .mode = MESH_MODE_NODE,  // ‚Üê Display —ç—Ç–æ NODE!
    .mesh_id = MESH_NETWORK_ID,
    .mesh_password = MESH_NETWORK_PASSWORD,
    .channel = MESH_NETWORK_CHANNEL,
    .max_connection = 6,
    .router_ssid = MESH_ROUTER_SSID,
    .router_password = MESH_ROUTER_PASSWORD,
    .router_bssid = NULL
};

mesh_manager_init(&mesh_config);
mesh_manager_register_recv_cb(on_mesh_data_received);  // ‚Üê Callback –¥–ª—è RESPONSE!
mesh_manager_start();
```

---

## üìã CHECKLIST –î–õ–Ø –ò–ò

–ü–µ—Ä–µ–¥ –∫–æ–º–º–∏—Ç–æ–º –ø—Ä–æ–≤–µ—Ä—å:

- [ ] ESP32-S3 —Å PSRAM 8MB (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ!)
- [ ] `MESH_MODE_NODE` (–ù–ï ROOT!)
- [ ] Callback `on_mesh_data_received` –¥–ª—è RESPONSE
- [ ] REQUEST –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
- [ ] Heartbeat –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
- [ ] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–æ–≤
- [ ] LVGL –±—É—Ñ–µ—Ä—ã –≤ PSRAM
- [ ] Encoder debouncing
- [ ] Backlight PWM (0-100%)
- [ ] UI –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
- [ ] –ù–ï–¢ –ø—Ä—è–º—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ NODE!
- [ ] –ö–æ–º–∞–Ω–¥—ã —á–µ—Ä–µ–∑ ROOT

---

## üéØ –ö–†–ò–¢–ï–†–ò–ò –£–°–ü–ï–•–ê

**NODE Display —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ –µ—Å–ª–∏:**

1. ‚úÖ –ü–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ ROOT –∫–∞–∫ NODE (layer 2)
2. ‚úÖ –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫
3. ‚úÖ –ü–æ–ª—É—á–∞–µ—Ç RESPONSE –æ—Ç ROOT
4. ‚úÖ –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –í–°–ï —É–∑–ª—ã (climate, ph_ec, relay, water)
5. ‚úÖ –≠–Ω–∫–æ–¥–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–∞–≤–∏–≥–∞—Ü–∏—è –ø–ª–∞–≤–Ω–∞—è)
6. ‚úÖ UI –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –±–µ–∑ –∑–∞–≤–∏—Å–∞–Ω–∏–π
7. ‚úÖ –ú–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∫–æ–º–∞–Ω–¥—ã —É–∑–ª–∞–º —á–µ—Ä–µ–∑ ROOT
8. ‚úÖ Heap —Å—Ç–∞–±–∏–ª—å–Ω—ã–π (~3.5 MB –≤ PSRAM)

---

**–ì–û–¢–û–í–û! Display NODE - –í–ò–ó–£–ê–õ–¨–ù–´–ô –ú–û–ù–ò–¢–û–†–ò–ù–ì –ß–ï–†–ï–ó MESH!** üì∫üéÆ

