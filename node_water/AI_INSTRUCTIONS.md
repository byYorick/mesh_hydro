# ü§ñ –ü–û–õ–ù–ê–Ø –ò–ù–°–¢–†–£–ö–¶–ò–Ø –î–õ–Ø –ò–ò: NODE Water

**–£–∑–µ–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–æ–¥–æ—Å–Ω–∞–±–∂–µ–Ω–∏–µ–º (–Ω–∞—Å–æ—Å, –∫–ª–∞–ø–∞–Ω—ã, –¥–∞—Ç—á–∏–∫ —É—Ä–æ–≤–Ω—è)**

---

## üéØ –ù–ê–ó–ù–ê–ß–ï–ù–ò–ï –£–ó–õ–ê

**NODE Water (ESP32)** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–∞—á–µ–π –∏ —Å–ª–∏–≤–æ–º –≤–æ–¥—ã –≤ –≥–∏–¥—Ä–æ–ø–æ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É.

### üíß –ö–ª—é—á–µ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:

1. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã** - —É–ª—å—Ç—Ä–∞–∑–≤—É–∫–æ–≤–æ–π –¥–∞—Ç—á–∏–∫ HC-SR04
2. **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤–Ω—ã–º –Ω–∞—Å–æ—Å–æ–º** - –ø–æ–¥–∞—á–∞ –≤–æ–¥—ã –∏–∑ –±–∞–∫–∞
3. **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥—Ä–µ–Ω–∞–∂–µ–º** - –∫–ª–∞–ø–∞–Ω —Å–ª–∏–≤–∞
4. **–ó–∞—â–∏—Ç–∞ –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å–æ—Å–∞
5. **–ó–∞—â–∏—Ç–∞ –æ—Ç —Å—É—Ö–æ–≥–æ —Ö–æ–¥–∞** - –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –Ω–∏–∑–∫–æ–º —É—Ä–æ–≤–Ω–µ
6. **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è** - –ª–∏—Ç—Ä—ã –∑–∞ —á–∞—Å/–¥–µ–Ω—å/–Ω–µ–¥–µ–ª—é

### ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–´–ï –ü–†–ê–í–ò–õ–ê:

1. ‚ùå **–ù–ï–¢ –ê–í–¢–û–ù–û–ú–ò–ò!** - Water —Ä–∞–±–æ—Ç–∞–µ—Ç –¢–û–õ–¨–ö–û –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –æ—Ç ROOT
2. ‚úÖ **SAFETY FIRST** - –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –∏ —Å—É—Ö–æ–≥–æ —Ö–æ–¥–∞
3. ‚úÖ **TIMEOUT PROTECTION** - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –Ω–∞—Å–æ—Å–∞
4. ‚úÖ **EMERGENCY STOP** - –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –∞–≤–∞—Ä–∏–∏
5. ‚ùå **–ù–ï –ø—Ä–∏–Ω–∏–º–∞–π —Ä–µ—à–µ–Ω–∏–π** - —Ç–æ–ª—å–∫–æ –∏—Å–ø–æ–ª–Ω—è–π –∫–æ–º–∞–Ω–¥—ã

---

## üì¶ –î–ê–¢–ß–ò–ö–ò –ò –ò–°–ü–û–õ–ù–ò–¢–ï–õ–ò

### –î–∞—Ç—á–∏–∫–∏:
| –î–∞—Ç—á–∏–∫ | –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å | GPIO | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ | –î–∏–∞–ø–∞–∑–æ–Ω |
|--------|-----------|------|------------|----------|
| **HC-SR04** | Ultrasonic | Trig=12, Echo=13 | –£—Ä–æ–≤–µ–Ω—å –≤–æ–¥—ã –≤ –±–∞–∫–µ | 2-400 cm |
| **Float Switch Low** | Digital | 14 | –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å | ON/OFF |
| **Float Switch High** | Digital | 27 | –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å | ON/OFF |

### –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏:
| –ê–∫—Ç—É–∞—Ç–æ—Ä | GPIO | –¢–∏–ø | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ |
|----------|------|-----|------------|
| **Main Pump** | 25 | Relay | –ù–∞—Å–æ—Å –ø–æ–¥–∞—á–∏ –≤–æ–¥—ã (12V, 20W) |
| **Drain Valve** | 26 | Solenoid | –ö–ª–∞–ø–∞–Ω —Å–ª–∏–≤–∞ (12V) |
| **Fill Valve** | 33 | Solenoid | –ö–ª–∞–ø–∞–Ω –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏—è (12V) |

### –ò–Ω–¥–∏–∫–∞—Ü–∏—è:
| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | GPIO | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ |
|-----------|------|------------|
| **LED Status** | 2 | –ó–µ–ª–µ–Ω—ã–π=OK, –ö—Ä–∞—Å–Ω—ã–π=Error |
| **Buzzer** | 15 | –ê–≤–∞—Ä–∏–π–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã |

---

## üîå –†–ê–°–ü–ò–ù–û–í–ö–ê ESP32

| GPIO | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ | –¢–∏–ø | –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ |
|------|------------|-----|------------|
| **–î–∞—Ç—á–∏–∫–∏ —É—Ä–æ–≤–Ω—è:** | | | |
| 12 | HC-SR04 Trig | Output | –£–ª—å—Ç—Ä–∞–∑–≤—É–∫–æ–≤–æ–π |
| 13 | HC-SR04 Echo | Input | –£–ª—å—Ç—Ä–∞–∑–≤—É–∫–æ–≤–æ–π |
| 14 | Float Switch Low | Input | Pullup, LOW=–≤–æ–¥–∞ –µ—Å—Ç—å |
| 27 | Float Switch High | Input | Pullup, LOW=–ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ |
| **–ê–∫—Ç—É–∞—Ç–æ—Ä—ã:** | | | |
| 25 | Main Pump | Relay | HIGH=–≤–∫–ª—é—á–µ–Ω |
| 26 | Drain Valve | Relay | HIGH=–æ—Ç–∫—Ä—ã—Ç |
| 33 | Fill Valve | Relay | HIGH=–æ—Ç–∫—Ä—ã—Ç |
| **–ò–Ω–¥–∏–∫–∞—Ü–∏—è:** | | | |
| 2 | Status LED | GPIO | –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π LED |
| 15 | Buzzer | GPIO | 5V –∞–∫—Ç–∏–≤–Ω—ã–π |

---

## üèóÔ∏è –ê–†–•–ò–¢–ï–ö–¢–£–†–ê

```
NODE Water (ESP32)
‚îÇ
‚îú‚îÄ‚îÄ Sensor Manager
‚îÇ   ‚îú‚îÄ‚îÄ HC-SR04 ultrasonic driver
‚îÇ   ‚îú‚îÄ‚îÄ Float switches (digital)
‚îÇ   ‚îú‚îÄ‚îÄ Water level calculation (cm)
‚îÇ   ‚îî‚îÄ‚îÄ Average filtering (5 samples)
‚îÇ
‚îú‚îÄ‚îÄ Pump Controller
‚îÇ   ‚îú‚îÄ‚îÄ Main pump (ON/OFF)
‚îÇ   ‚îú‚îÄ‚îÄ Safety timeout (max 10 min)
‚îÇ   ‚îú‚îÄ‚îÄ Dry run protection
‚îÇ   ‚îî‚îÄ‚îÄ Statistics (liters/hour/day)
‚îÇ
‚îú‚îÄ‚îÄ Valve Controller
‚îÇ   ‚îú‚îÄ‚îÄ Drain valve (ON/OFF)
‚îÇ   ‚îú‚îÄ‚îÄ Fill valve (ON/OFF)
‚îÇ   ‚îú‚îÄ‚îÄ Interlock (–Ω–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ!)
‚îÇ   ‚îî‚îÄ‚îÄ Timeout protection
‚îÇ
‚îú‚îÄ‚îÄ Command Handler
‚îÇ   ‚îú‚îÄ‚îÄ –ö–æ–º–∞–Ω–¥—ã –æ—Ç ROOT
‚îÇ   ‚îú‚îÄ‚îÄ Validation
‚îÇ   ‚îú‚îÄ‚îÄ Execution
‚îÇ   ‚îî‚îÄ‚îÄ Status response
‚îÇ
‚îú‚îÄ‚îÄ Mesh Client (NODE mode)
‚îÇ   ‚îú‚îÄ‚îÄ Receive commands ‚Üê ROOT
‚îÇ   ‚îú‚îÄ‚îÄ Send status ‚Üí ROOT
‚îÇ   ‚îú‚îÄ‚îÄ Heartbeat every 10 sec
‚îÇ   ‚îî‚îÄ‚îÄ Emergency events
‚îÇ
‚îî‚îÄ‚îÄ Safety Monitor
    ‚îú‚îÄ‚îÄ Overflow protection (float high)
    ‚îú‚îÄ‚îÄ Dry run protection (float low)
    ‚îú‚îÄ‚îÄ Timeout checks
    ‚îî‚îÄ‚îÄ Emergency stop
```

---

## üì® –¢–ò–ü–´ –°–û–û–ë–©–ï–ù–ò–ô

### 1. üì§ STATUS (–∫–∞–∂–¥—ã–µ 10 —Å–µ–∫ –∏–ª–∏ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã)

**NODE ‚Üí ROOT ‚Üí MQTT ‚Üí Server**

```json
{
  "type": "telemetry",
  "node_id": "water_001",
  "timestamp": 1729346400,
  "data": {
    "water_level_cm": 45,
    "water_level_percent": 75,
    "float_low": true,
    "float_high": false,
    "pump_running": false,
    "drain_open": false,
    "fill_open": false,
    "pump_runtime_today_sec": 1800,
    "water_used_today_liters": 150,
    "rssi_to_parent": -48
  }
}
```

**–ö–æ–¥:**
```c
static void send_status(void) {
    float level_cm = water_level_read_cm();
    float level_percent = (level_cm / TANK_HEIGHT_CM) * 100.0f;
    
    cJSON *data = cJSON_CreateObject();
    cJSON_AddNumberToObject(data, "water_level_cm", level_cm);
    cJSON_AddNumberToObject(data, "water_level_percent", level_percent);
    cJSON_AddBoolToObject(data, "float_low", gpio_get_level(FLOAT_LOW_GPIO) == 0);
    cJSON_AddBoolToObject(data, "float_high", gpio_get_level(FLOAT_HIGH_GPIO) == 0);
    cJSON_AddBoolToObject(data, "pump_running", pump_is_running());
    cJSON_AddBoolToObject(data, "drain_open", valve_is_open(VALVE_DRAIN));
    cJSON_AddBoolToObject(data, "fill_open", valve_is_open(VALVE_FILL));
    cJSON_AddNumberToObject(data, "pump_runtime_today_sec", pump_get_runtime_today());
    cJSON_AddNumberToObject(data, "water_used_today_liters", pump_get_liters_today());
    cJSON_AddNumberToObject(data, "rssi_to_parent", mesh_manager_get_parent_rssi());
    
    char json_buf[512];
    mesh_protocol_create_telemetry(s_config->base.node_id, data, json_buf, sizeof(json_buf));
    mesh_manager_send_to_root((uint8_t *)json_buf, strlen(json_buf));
    
    cJSON_Delete(data);
}
```

---

### 2. üì• COMMAND (Server ‚Üí MQTT ‚Üí ROOT ‚Üí NODE)

**–¢–æ–ø–∏–∫:** `hydro/command/water_001`

#### a) –ó–∞–ø—É—Å–∫ –Ω–∞—Å–æ—Å–∞:
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "run_pump",
  "params": {
    "duration_sec": 60
  }
}
```

#### b) –û—Ç–∫—Ä—ã—Ç—å –¥—Ä–µ–Ω–∞–∂:
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "open_drain",
  "params": {
    "duration_sec": 30
  }
}
```

#### c) –ù–∞–ø–æ–ª–Ω–∏—Ç—å –±–∞–∫:
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "fill_tank",
  "params": {
    "target_level_cm": 50  // –ù–∞–ø–æ–ª–Ω–∏—Ç—å –¥–æ 50 —Å–º
  }
}
```

#### d) Emergency stop:
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "emergency_stop",
  "params": {}
}
```

**–û–±—Ä–∞–±–æ—Ç–∫–∞:**
```c
void water_controller_handle_command(const char *command, cJSON *params) {
    ESP_LOGI(TAG, "Command received: %s", command);
    
    if (strcmp(command, "run_pump") == 0) {
        cJSON *duration = cJSON_GetObjectItem(params, "duration_sec");
        
        if (duration && cJSON_IsNumber(duration)) {
            uint32_t duration_sec = (uint32_t)duration->valueint;
            
            esp_err_t err = pump_controller_run(duration_sec);
            
            if (err == ESP_OK) {
                ESP_LOGI(TAG, "Pump started for %d sec", duration_sec);
            } else {
                ESP_LOGE(TAG, "Pump start failed: %s", esp_err_to_name(err));
                send_error_event("Pump start failed");
            }
            
            send_status();
        }
    }
    else if (strcmp(command, "open_drain") == 0) {
        cJSON *duration = cJSON_GetObjectItem(params, "duration_sec");
        
        if (duration && cJSON_IsNumber(duration)) {
            valve_controller_open(VALVE_DRAIN, duration->valueint);
            send_status();
        }
    }
    else if (strcmp(command, "fill_tank") == 0) {
        cJSON *target = cJSON_GetObjectItem(params, "target_level_cm");
        
        if (target && cJSON_IsNumber(target)) {
            float target_cm = (float)target->valuedouble;
            water_controller_fill_to_level(target_cm);
        }
    }
    else if (strcmp(command, "emergency_stop") == 0) {
        water_controller_emergency_stop();
    }
}
```

---

### 3. üíì HEARTBEAT (–∫–∞–∂–¥—ã–µ 10 —Å–µ–∫)

```json
{
  "type": "heartbeat",
  "node_id": "water_001",
  "uptime": 3600,
  "heap_free": 200000,
  "rssi_to_parent": -48
}
```

---

### 4. üîî EVENT (–∞–≤–∞—Ä–∏–∏)

**–ö–æ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å:**
- –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–∫–∞ (float_high triggered)
- –ù–∏–∑–∫–∏–π —É—Ä–æ–≤–µ–Ω—å (float_low triggered)
- –ù–∞—Å–æ—Å —Ä–∞–±–æ—Ç–∞–µ—Ç > 10 –º–∏–Ω
- Dry run protection —Å—Ä–∞–±–æ—Ç–∞–ª–∞
- –ö–ª–∞–ø–∞–Ω—ã –æ—Ç–∫—Ä—ã—Ç—ã –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ (interlock error)

```json
{
  "type": "event",
  "node_id": "water_001",
  "timestamp": 1729346400,
  "level": "critical",
  "message": "Tank overflow detected",
  "data": {
    "water_level_cm": 65,
    "float_high": true,
    "action": "pump_stopped"
  }
}
```

---

## üíß –£–ü–†–ê–í–õ–ï–ù–ò–ï –í–û–î–û–ô

### –õ–æ–≥–∏–∫–∞ –∑–∞–ø—É—Å–∫–∞ –Ω–∞—Å–æ—Å–∞:

```c
esp_err_t pump_controller_run(uint32_t duration_sec) {
    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ float switches
    if (gpio_get_level(FLOAT_LOW_GPIO) == 1) {  // HIGH = –Ω–µ—Ç –≤–æ–¥—ã
        ESP_LOGE(TAG, "Cannot run pump - water level too low (dry run protection)");
        send_error_event("Dry run protection");
        return ESP_ERR_INVALID_STATE;
    }
    
    if (gpio_get_level(FLOAT_HIGH_GPIO) == 0) {  // LOW = –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
        ESP_LOGW(TAG, "Cannot run pump - tank is full");
        return ESP_ERR_INVALID_STATE;
    }
    
    // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
    if (duration_sec > PUMP_MAX_DURATION_SEC) {
        ESP_LOGW(TAG, "Duration too long: %d sec (max %d)", duration_sec, PUMP_MAX_DURATION_SEC);
        duration_sec = PUMP_MAX_DURATION_SEC;
    }
    
    // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ –≤ —Å—É—Ç–∫–∏
    if (s_pump_runtime_today_sec > PUMP_MAX_RUNTIME_PER_DAY_SEC) {
        ESP_LOGE(TAG, "Daily runtime limit exceeded");
        send_error_event("Pump daily limit exceeded");
        return ESP_ERR_INVALID_STATE;
    }
    
    // 4. –ó–∞–ø—É—Å–∫ –Ω–∞—Å–æ—Å–∞
    s_pump_running = true;
    s_pump_start_time = xTaskGetTickCount();
    gpio_set_level(PUMP_GPIO, 1);
    
    ESP_LOGI(TAG, "Pump started (duration=%d sec)", duration_sec);
    
    // 5. –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    xTaskCreate(pump_monitor_task, "pump_mon", 2048, (void *)(intptr_t)duration_sec, 5, &s_pump_monitor_task);
    
    return ESP_OK;
}

// –ó–∞–¥–∞—á–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –Ω–∞—Å–æ—Å–∞:
static void pump_monitor_task(void *arg) {
    uint32_t duration_sec = (uint32_t)(intptr_t)arg;
    uint32_t elapsed_sec = 0;
    
    while (elapsed_sec < duration_sec) {
        vTaskDelay(pdMS_TO_TICKS(1000));
        elapsed_sec++;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –ö–ê–ñ–î–£–Æ –°–ï–ö–£–ù–î–£
        if (gpio_get_level(FLOAT_HIGH_GPIO) == 0) {
            ESP_LOGW(TAG, "Tank full - stopping pump");
            pump_controller_stop();
            send_warning_event("Tank full - pump auto-stopped");
            vTaskDelete(NULL);
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—Ö–æ–≥–æ —Ö–æ–¥–∞
        if (gpio_get_level(FLOAT_LOW_GPIO) == 1) {
            ESP_LOGE(TAG, "Water level too low - stopping pump");
            pump_controller_stop();
            send_error_event("Dry run protection activated");
            vTaskDelete(NULL);
            return;
        }
    }
    
    // –ù–æ—Ä–º–∞–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ —Ç–∞–π–º–µ—Ä—É
    pump_controller_stop();
    ESP_LOGI(TAG, "Pump stopped (duration complete)");
    
    vTaskDelete(NULL);
}
```

---

### –ò–∑–º–µ—Ä–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã (HC-SR04):

```c
float water_level_read_cm(void) {
    const int NUM_SAMPLES = 5;
    float samples[NUM_SAMPLES];
    int valid_count = 0;
    
    // –ë–µ—Ä–µ–º 5 –∏–∑–º–µ—Ä–µ–Ω–∏–π
    for (int i = 0; i < NUM_SAMPLES; i++) {
        // –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–º–ø—É–ª—å—Å–∞ (10 –º–∫—Å)
        gpio_set_level(TRIG_GPIO, 0);
        esp_rom_delay_us(2);
        gpio_set_level(TRIG_GPIO, 1);
        esp_rom_delay_us(10);
        gpio_set_level(TRIG_GPIO, 0);
        
        // –û–∂–∏–¥–∞–Ω–∏–µ echo (timeout 30ms)
        int64_t start = esp_timer_get_time();
        while (gpio_get_level(ECHO_GPIO) == 0) {
            if ((esp_timer_get_time() - start) > 30000) break;
        }
        
        start = esp_timer_get_time();
        while (gpio_get_level(ECHO_GPIO) == 1) {
            if ((esp_timer_get_time() - start) > 30000) break;
        }
        int64_t duration_us = esp_timer_get_time() - start;
        
        // –†–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (—Å–º)
        float distance_cm = (duration_us * 0.0343f) / 2.0f;
        
        // –í–∞–ª–∏–¥–∞—Ü–∏—è (2-400 —Å–º)
        if (distance_cm > 2.0f && distance_cm < 400.0f) {
            samples[valid_count++] = distance_cm;
        }
        
        vTaskDelay(pdMS_TO_TICKS(100));  // 100ms –º–µ–∂–¥—É –∏–∑–º–µ—Ä–µ–Ω–∏—è–º–∏
    }
    
    // –°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    if (valid_count == 0) {
        ESP_LOGE(TAG, "All HC-SR04 measurements failed");
        return -1.0f;
    }
    
    float sum = 0.0f;
    for (int i = 0; i < valid_count; i++) {
        sum += samples[i];
    }
    
    float avg_distance = sum / (float)valid_count;
    
    // –£—Ä–æ–≤–µ–Ω—å –≤–æ–¥—ã = –≤—ã—Å–æ—Ç–∞ –±–∞–∫–∞ - —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –¥–∞—Ç—á–∏–∫–∞
    float water_level = TANK_HEIGHT_CM - avg_distance;
    
    ESP_LOGD(TAG, "Water level: %.1f cm (%.0f%%)", water_level, (water_level / TANK_HEIGHT_CM) * 100.0f);
    
    return water_level;
}
```

---

### –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª–∞–ø–∞–Ω–∞–º–∏:

```c
esp_err_t valve_controller_open(valve_type_t valve, uint32_t duration_sec) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ interlock (–Ω–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å drain –∏ fill –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ!)
    if (valve == VALVE_DRAIN && s_valve_fill_open) {
        ESP_LOGE(TAG, "Cannot open drain - fill valve is open!");
        return ESP_ERR_INVALID_STATE;
    }
    
    if (valve == VALVE_FILL && s_valve_drain_open) {
        ESP_LOGE(TAG, "Cannot open fill - drain valve is open!");
        return ESP_ERR_INVALID_STATE;
    }
    
    int gpio = (valve == VALVE_DRAIN) ? DRAIN_GPIO : FILL_GPIO;
    bool *is_open = (valve == VALVE_DRAIN) ? &s_valve_drain_open : &s_valve_fill_open;
    
    // –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–ª–∞–ø–∞–Ω–∞
    gpio_set_level(gpio, 1);
    *is_open = true;
    
    ESP_LOGI(TAG, "Valve %s opened (duration=%d sec)", 
             valve == VALVE_DRAIN ? "DRAIN" : "FILL", duration_sec);
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ auto-close
    if (duration_sec > 0) {
        xTaskCreate(valve_auto_close_task, "valve_close", 2048, 
                    (void *)(intptr_t)valve, 5, NULL);
    }
    
    return ESP_OK;
}

esp_err_t valve_controller_close(valve_type_t valve) {
    int gpio = (valve == VALVE_DRAIN) ? DRAIN_GPIO : FILL_GPIO;
    bool *is_open = (valve == VALVE_DRAIN) ? &s_valve_drain_open : &s_valve_fill_open;
    
    gpio_set_level(gpio, 0);
    *is_open = false;
    
    ESP_LOGI(TAG, "Valve %s closed", valve == VALVE_DRAIN ? "DRAIN" : "FILL");
    return ESP_OK;
}
```

---

## üì® –ü–†–ò–ú–ï–†–´ –ö–û–ú–ê–ù–î

### 1. –ù–∞–ø–æ–ª–Ω–∏—Ç—å –±–∞–∫ –¥–æ 50 —Å–º:

**–ö–æ–º–∞–Ω–¥–∞:**
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "fill_tank",
  "params": {
    "target_level_cm": 50
  }
}
```

**–õ–æ–≥–∏–∫–∞:**
```c
void water_controller_fill_to_level(float target_cm) {
    float current_level = water_level_read_cm();
    
    if (current_level >= target_cm) {
        ESP_LOGI(TAG, "Tank already at target level");
        return;
    }
    
    ESP_LOGI(TAG, "Filling tank: %.1f ‚Üí %.1f cm", current_level, target_cm);
    
    // –û—Ç–∫—Ä—ã—Ç—å fill valve
    valve_controller_open(VALVE_FILL, 0);  // 0 = –±–µ–∑ auto-close
    
    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    xTaskCreate(fill_monitor_task, "fill_mon", 2048, 
                (void *)(intptr_t)(target_cm * 10), 5, NULL);
}

static void fill_monitor_task(void *arg) {
    float target_cm = (float)((int)(intptr_t)arg) / 10.0f;
    
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(2000));  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫
        
        float current_level = water_level_read_cm();
        
        // –î–æ—Å—Ç–∏–≥–ª–∏ —É—Ä–æ–≤–Ω—è?
        if (current_level >= target_cm) {
            valve_controller_close(VALVE_FILL);
            ESP_LOGI(TAG, "Tank filled to %.1f cm", current_level);
            send_status();
            vTaskDelete(NULL);
            return;
        }
        
        // Timeout 10 –º–∏–Ω—É—Ç
        static int counter = 0;
        if (counter++ > 300) {  // 300 * 2 —Å–µ–∫ = 10 –º–∏–Ω
            valve_controller_close(VALVE_FILL);
            ESP_LOGE(TAG, "Fill timeout!");
            send_error_event("Fill tank timeout");
            vTaskDelete(NULL);
            return;
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ progress
        if (counter % 15 == 0) {  // –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫
            send_status();
        }
    }
}
```

---

### 2. –°–ª–∏–≤ –≤–æ–¥—ã:

**–ö–æ–º–∞–Ω–¥–∞:**
```json
{
  "type": "command",
  "node_id": "water_001",
  "command": "drain_tank",
  "params": {
    "target_level_cm": 10  // –°–ª–∏—Ç—å –¥–æ 10 —Å–º (–Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é)
  }
}
```

---

## üö® SAFETY PROTECTION

### 1. Overflow protection:

```c
// ISR –æ—Ç float switch HIGH
void IRAM_ATTR float_high_isr(void *arg) {
    // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å–æ—Å–∞ –∏ fill valve!
    gpio_set_level(PUMP_GPIO, 0);
    gpio_set_level(FILL_VALVE_GPIO, 0);
    
    s_overflow_detected = true;
    
    ESP_LOGE(TAG, "OVERFLOW DETECTED!");
}

// –í –≥–ª–∞–≤–Ω–æ–π –∑–∞–¥–∞—á–µ:
if (s_overflow_detected) {
    s_overflow_detected = false;
    send_emergency_event("Tank overflow - pump auto-stopped");
}
```

### 2. Dry run protection:

```c
// ISR –æ—Ç float switch LOW
void IRAM_ATTR float_low_isr(void *arg) {
    // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å–æ—Å–∞!
    gpio_set_level(PUMP_GPIO, 0);
    
    s_dry_run_detected = true;
    
    ESP_LOGE(TAG, "DRY RUN DETECTED!");
}

// –í –≥–ª–∞–≤–Ω–æ–π –∑–∞–¥–∞—á–µ:
if (s_dry_run_detected) {
    s_dry_run_detected = false;
    send_emergency_event("Water level too low - pump auto-stopped");
}
```

### 3. Interlock protection:

```c
// –ù–ï –û–¢–ö–†–´–í–ê–¢–¨ drain –∏ fill –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ!
if (valve_is_open(VALVE_DRAIN) && valve_is_open(VALVE_FILL)) {
    ESP_LOGE(TAG, "INTERLOCK VIOLATION!");
    valve_controller_close(VALVE_DRAIN);
    valve_controller_close(VALVE_FILL);
    send_emergency_event("Valve interlock violation");
}
```

---

## üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê

### –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è –≤–æ–¥—ã:

```c
typedef struct {
    uint32_t pump_runtime_today_sec;    // –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –∑–∞ —Å—É—Ç–∫–∏
    uint32_t pump_cycles_today;          // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–æ–≤
    float water_used_today_liters;       // –ü–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –∑–∞ —Å—É—Ç–∫–∏
    uint32_t last_reset_timestamp;       // –ö–æ–≥–¥–∞ —Å–±—Ä–æ—Å–∏–ª–∏ —Å—á—ë—Ç—á–∏–∫–∏
} water_stats_t;

// –†–∞—Å—á–µ—Ç —Ä–∞—Å—Ö–æ–¥–∞ (–ø—Ä–∏–º–µ—Ä–Ω—ã–π, –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã):
// –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞—Å–æ—Å–∞: ~5 –ª/–º–∏–Ω
void pump_controller_update_stats(uint32_t runtime_sec) {
    const float PUMP_FLOW_RATE_LPM = 5.0f;  // –ª/–º–∏–Ω
    
    s_stats.pump_runtime_today_sec += runtime_sec;
    s_stats.pump_cycles_today++;
    
    float liters = (runtime_sec / 60.0f) * PUMP_FLOW_RATE_LPM;
    s_stats.water_used_today_liters += liters;
    
    ESP_LOGI(TAG, "Water used today: %.1f L (%d cycles, %d sec runtime)",
             s_stats.water_used_today_liters,
             s_stats.pump_cycles_today,
             s_stats.pump_runtime_today_sec);
    
    // –°–±—Ä–æ—Å —Å—á—ë—Ç—á–∏–∫–æ–≤ –≤ –ø–æ–ª–Ω–æ—á—å
    time_t now = time(NULL);
    struct tm timeinfo;
    localtime_r(&now, &timeinfo);
    
    if (timeinfo.tm_hour == 0 && timeinfo.tm_min == 0) {
        memset(&s_stats, 0, sizeof(water_stats_t));
        ESP_LOGI(TAG, "Daily stats reset");
    }
}
```

---

## üåê MESH INTEGRATION

### –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (NODE —Ä–µ–∂–∏–º):

```c
void app_main(void) {
    // === –®–∞–≥ 1-2: NVS + Config ===
    nvs_flash_init();
    node_config_load(&g_config, sizeof(g_config), "water_ns");
    
    // === –®–∞–≥ 3: GPIO (–¥–∞—Ç—á–∏–∫–∏ –∏ —Ä–µ–ª–µ) ===
    // ...
    
    // === –®–∞–≥ 4: ISR –¥–ª—è float switches ===
    gpio_install_isr_service(0);
    gpio_isr_handler_add(FLOAT_LOW_GPIO, float_low_isr, NULL);
    gpio_isr_handler_add(FLOAT_HIGH_GPIO, float_high_isr, NULL);
    
    // === –®–∞–≥ 5: Mesh (NODE —Ä–µ–∂–∏–º) ===
    mesh_manager_config_t mesh_config = {
        .mode = MESH_MODE_NODE,
        .mesh_id = MESH_NETWORK_ID,
        .mesh_password = MESH_NETWORK_PASSWORD,
        .channel = MESH_NETWORK_CHANNEL,
        .max_connection = 6,
        .router_ssid = MESH_ROUTER_SSID,
        .router_password = MESH_ROUTER_PASSWORD,
        .router_bssid = NULL
    };
    mesh_manager_init(&mesh_config);
    mesh_manager_register_recv_cb(on_mesh_data_received);
    mesh_manager_start();
    
    // === –®–∞–≥ 6: –ó–∞–ø—É—Å–∫ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ ===
    water_controller_init(&g_config);
    water_controller_start();
}
```

---

## ‚ùå –ß–¢–û –ù–ï –î–ï–õ–ê–¢–¨

### 1. ‚ùå –ù–ï –∑–∞–ø—É—Å–∫–∞–π –Ω–∞—Å–æ—Å –±–µ–∑ safety checks

```c
// –ü–õ–û–•–û ‚ùå
gpio_set_level(PUMP_GPIO, 1);
vTaskDelay(pdMS_TO_TICKS(60000));
gpio_set_level(PUMP_GPIO, 0);  // ‚ùå –ù–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è!

// –•–û–†–û–®–û ‚úÖ
pump_controller_run(60);  // ‚úÖ –° overflow –∏ dry run protection
```

### 2. ‚ùå –ù–ï –æ—Ç–∫—Ä—ã–≤–∞–π –æ–±–∞ –∫–ª–∞–ø–∞–Ω–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

```c
// –ü–õ–û–•–û ‚ùå
gpio_set_level(DRAIN_VALVE_GPIO, 1);
gpio_set_level(FILL_VALVE_GPIO, 1);  // ‚ùå Interlock violation!

// –•–û–†–û–®–û ‚úÖ
valve_controller_open(VALVE_FILL, 60);  // ‚úÖ –° interlock check
```

### 3. ‚ùå –ù–ï –ø—Ä–∏–Ω–∏–º–∞–π —Ä–µ—à–µ–Ω–∏–π –∞–≤—Ç–æ–Ω–æ–º–Ω–æ

```c
// –ü–õ–û–•–û ‚ùå
if (water_level_read_cm() < 20.0f) {
    pump_controller_run(120);  // ‚ùå –ù–µ—Ç –∞–≤—Ç–æ–Ω–æ–º–∏–∏!
}

// –•–û–†–û–®–û ‚úÖ
// –û—Ç–ø—Ä–∞–≤—å —Å—Ç–∞—Ç—É—Å –Ω–∞ ROOT, ROOT –ø—Ä–∏–º–µ—Ç —Ä–µ—à–µ–Ω–∏–µ
send_status();
```

---

## üß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï

### –¢–µ—Å—Ç –∑–∞–ø—É—Å–∫–∞ –Ω–∞—Å–æ—Å–∞:

```bash
mosquitto_pub -h 192.168.1.100 -t hydro/command/water_001 -m '{
  "type": "command",
  "node_id": "water_001",
  "command": "run_pump",
  "params": {"duration_sec": 30}
}'
```

**–û–∂–∏–¥–∞–µ–º—ã–π –ª–æ–≥:**
```
I (5000) water_ctrl: Command received: run_pump
I (5000) pump_ctrl: Pump started (duration=30 sec)
... (—á–µ—Ä–µ–∑ 30 —Å–µ–∫)
I (35000) pump_ctrl: Pump stopped (duration complete)
I (35010) water_ctrl: Status sent to ROOT
```

### –¢–µ—Å—Ç –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–∫–∞:

```bash
mosquitto_pub -h 192.168.1.100 -t hydro/command/water_001 -m '{
  "type": "command",
  "node_id": "water_001",
  "command": "fill_tank",
  "params": {"target_level_cm": 50}
}'
```

---

## üìã CHECKLIST –î–õ–Ø –ò–ò

–ü–µ—Ä–µ–¥ –∫–æ–º–º–∏—Ç–æ–º –ø—Ä–æ–≤–µ—Ä—å:

- [ ] `MESH_MODE_NODE` (–ù–ï ROOT!)
- [ ] Callback `on_mesh_data_received` –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
- [ ] –ö–æ–º–∞–Ω–¥—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è
- [ ] –°—Ç–∞—Ç—É—Å –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥—ã
- [ ] Heartbeat –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫
- [ ] Overflow protection (float_high ISR)
- [ ] Dry run protection (float_low ISR)
- [ ] Timeout –¥–ª—è –Ω–∞—Å–æ—Å–∞ (–º–∞–∫—Å 10 –º–∏–Ω)
- [ ] Timeout –¥–ª—è –∫–ª–∞–ø–∞–Ω–æ–≤
- [ ] Interlock –¥–ª—è –∫–ª–∞–ø–∞–Ω–æ–≤ (–Ω–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –≤–º–µ—Å—Ç–µ)
- [ ] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–ª–∏—Ç—Ä—ã –∑–∞ –¥–µ–Ω—å)
- [ ] –ù–ï–¢ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π –ª–æ–≥–∏–∫–∏!
- [ ] –ù–ï–¢ –¥–∞—Ç—á–∏–∫–æ–≤ (–∫—Ä–æ–º–µ —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã)!

---

## üéØ –ö–†–ò–¢–ï–†–ò–ò –£–°–ü–ï–•–ê

**NODE Water —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ –µ—Å–ª–∏:**

1. ‚úÖ –ü–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ ROOT –∫–∞–∫ NODE (layer 2)
2. ‚úÖ –ò—Å–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–∞–Ω–¥—ã –æ—Ç ROOT/Server
3. ‚úÖ –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫
4. ‚úÖ Overflow protection —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–∞—Å–æ—Å –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è)
5. ‚úÖ Dry run protection —Ä–∞–±–æ—Ç–∞–µ—Ç
6. ‚úÖ Interlock –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–ª–∞–ø–∞–Ω–æ–≤
7. ‚úÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è
8. ‚úÖ –ù–ï —Ä–∞–±–æ—Ç–∞–µ—Ç –∞–≤—Ç–æ–Ω–æ–º–Ω–æ (—Ç–æ–ª—å–∫–æ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º)

---

**–ì–û–¢–û–í–û! Water NODE - –£–ü–†–ê–í–õ–ï–ù–ò–ï –í–û–î–û–°–ù–ê–ë–ñ–ï–ù–ò–ï–ú –ü–û –ö–û–ú–ê–ù–î–ê–ú!** üíßüö∞

